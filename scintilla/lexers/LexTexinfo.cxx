// This file is part of Notepad2.
// See License.txt for details about distribution and modification.
//! Lexer for GNU Texinfo.

#include <cassert>
#include <cstring>

#include <string>
#include <string_view>

#include "ILexer.h"
#include "Scintilla.h"
#include "SciLexer.h"

#include "WordList.h"
#include "LexAccessor.h"
#include "Accessor.h"
#include "StyleContext.h"
#include "CharacterSet.h"
#include "StringUtils.h"
#include "LexerModule.h"

using namespace Lexilla;

namespace {

//KeywordIndex++Autogenerated -- start of section automatically generated
enum {
	KeywordIndex_Command = 0,
	KeywordIndex_CodeFolding = 1,
};
//KeywordIndex--Autogenerated -- end of section automatically generated

enum class KeywordType {
	None = SCE_L_DEFAULT,
	End = SCE_L_TAG2,
};

enum {
	TexinfoLineStateTeX = 1,
	TexinfoLineStateMask = 1,
};

constexpr bool IsTexiSpecial(int ch) noexcept {
	// https://www.gnu.org/software/texinfo/manual/texinfo/html_node/Command-Syntax.html
	// treat space and punctuation as special
	return ch <= ' ' || (ch < 127 && !IsADigit(ch));
}

constexpr bool IsSingleLine(int state) noexcept {
	return state == SCE_L_TITLE
		|| state == SCE_L_CHAPTER
		|| state == SCE_L_SECTION
		|| state == SCE_L_SECTION1
		|| state == SCE_L_SECTION2;
}

bool MatchEnd(const StyleContext &sc) noexcept {
	if (sc.Match("@end")) {
		const char *word = (sc.state == SCE_L_COMMENT2) ? "ignore" : "verbatim";
		const size_t len = (sc.state == SCE_L_COMMENT2) ? CStrLen("ignore") : CStrLen("verbatim");
		Sci_PositionU pos = sc.currentPos + CStrLen("@end");
		for (; pos < sc.lineStartNext; pos++) {
			const char ch = sc.styler[pos];
			if (ch == word[0]) {
				if (sc.styler.Match(pos, word) && !IsAlpha(sc.styler[pos + len])) {
					return true;
				}
				break;
			}
			if (!IsSpaceOrTab(ch)) {
				break;
			}
		}
	}
	return false;
}

void ColouriseTexiDoc(Sci_PositionU startPos, Sci_Position lengthDoc, int initStyle, LexerWordList keywordLists, Accessor &styler) {
	const bool fold = styler.GetPropertyBool("fold");

	int visibleChars = 0;
	int outerState = SCE_L_DEFAULT;
	int braceCount = 0;
	int mathBraceCount = 0;
	int headerLevel = 0;
	int levelCurrent = SC_FOLDLEVELBASE;
	KeywordType kwType = KeywordType::None;
	int delimiter = 0;
	int lineState = 0;

	StyleContext sc(startPos, lengthDoc, initStyle, styler);
	if (sc.currentLine > 0) {
		levelCurrent = styler.LevelAt(sc.currentLine - 1) >> 16;
		lineState = styler.GetLineState(sc.currentLine - 1);
		braceCount = lineState >> 8;
		lineState &= TexinfoLineStateMask;
	}
	if (startPos == 0 && sc.Match('\\', 'i')) {
		// \input at document beginning
		sc.SetState(SCE_L_TAG);
		sc.Forward();
	}

	int levelNext = levelCurrent;
	while (sc.More()) {
		if (sc.atLineStart) {
			if (sc.state == SCE_L_COMMENT || IsSingleLine(sc.state)) {
				if (sc.state != SCE_L_COMMENT) {
					outerState = SCE_L_DEFAULT;
					braceCount = 0;
				}
				sc.SetState(SCE_L_DEFAULT);
			}
		}

		switch (sc.state) {
		case SCE_L_OPERATOR:
		case SCE_L_SPECIAL:
			sc.SetState(braceCount ? SCE_L_DEFAULT : outerState);
			break;

		case SCE_L_COMMAND:
			if (!IsAlpha(sc.ch)) {
				char s[32];
				sc.GetCurrent(s, sizeof(s));
				const char *p = s + 1;
				int state = braceCount ? SCE_L_DEFAULT : outerState;
				kwType = KeywordType::None;
				if (keywordLists[KeywordIndex_CodeFolding].InList(p)) {
					levelNext++;
					braceCount = 0;
					if (StrEqual(p, "ignore")) {
						state = SCE_L_COMMENT2;
					} else if (StrEqual(p, "verbatim")) {
						state = SCE_L_VERBATIM2;
					} else if (StrEqualsAny(p, "tex", "latex", "displaymath")) {
						lineState = TexinfoLineStateTeX;
					}
				} else if (!keywordLists[KeywordIndex_Command].InList(p)) {
					sc.ChangeState(SCE_L_MARCO);
				} else if (StrEqualsAny(p, "c", "comment")) {
					sc.ChangeState(SCE_L_COMMENT);
				} else if (StrEqual(p, "end")) {
					levelNext--;
					kwType = KeywordType::End;
					state = SCE_L_DEFAULT;
					lineState = 0;
					braceCount = 0;
				} else if (StrEqualsAny(p, "chapter", "chapheading", "majorheading")) {
					state = SCE_L_CHAPTER;
				} else if (StrEqualsAny(p, "section", "heading")) {
					state = SCE_L_SECTION;
				} else if (StrEqualsAny(p, "subsection", "subheading")) {
					state = SCE_L_SECTION1;
				} else if (StrEqualsAny(p, "subsubsection", "subsubheading")) {
					state = SCE_L_SECTION2;
				} else if (StrEqualsAny(p, "title", "settitle", "top")) {
					state = SCE_L_TITLE;
				} else if (StrStartsWith(p, "appendix") || StrStartsWith(p, "unnumbered")) {
					p += (p[0] == 'a') ? CStrLen("appendix") : CStrLen("unnumbered");
					if (*p == '\0')	{
						state = SCE_L_CHAPTER;
					} else if (StrEqualsAny(p, "sec", "section")) {
						state = SCE_L_SECTION;
					} else if (StrEqual(p, "subsec")) {
						state = SCE_L_SECTION1;
					} else if (StrEqual(p, "subsubsec")) {
						state = SCE_L_SECTION2;
					}
				} else if (StrEqual(p, "verb")) {
					if (sc.ch == '{' && sc.chNext != '}' && IsAGraphic(sc.chNext)) {
						state = SCE_L_OPERATOR;
						delimiter = sc.chNext;
					}
				} else if (StrEqual(p, "math")) {
					if (sc.ch == '{') {
						mathBraceCount = braceCount + 1;
					}
				}
				if (sc.state != SCE_L_COMMENT) {
					if (IsSingleLine(state)) {
						outerState = state;
						braceCount = 0;
						headerLevel = state - SCE_L_TITLE;
					}
					sc.SetState(state);
					if (state == SCE_L_OPERATOR) {
						sc.ForwardSetState(SCE_L_VERBATIM);
					}
				}
			}
			break;

		case SCE_L_TAG:
		case SCE_L_TAG2:
			if (!IsAlpha(sc.ch)) {
				sc.SetState(braceCount ? SCE_L_DEFAULT : outerState);
			}
			break;

		case SCE_L_VERBATIM:
			if (sc.chNext == '}' && sc.ch == delimiter) {
				sc.ForwardSetState(SCE_L_OPERATOR);
				sc.ForwardSetState(braceCount ? SCE_L_DEFAULT : outerState);
			}
			break;

		case SCE_L_COMMENT2:
		case SCE_L_VERBATIM2:
			if (visibleChars == 0 && MatchEnd(sc)) {
				sc.SetState(SCE_L_COMMAND);
			}
			break;
		}

		if (sc.state == SCE_L_DEFAULT || IsSingleLine(sc.state)) {
			if (kwType == KeywordType::End && sc.ch > ' ') {
				kwType = KeywordType::None;
				if (IsAlpha(sc.ch)) {
					sc.SetState(SCE_L_TAG2);
				}
			}
			if (sc.ch == '@' && lineState == 0) {
				if (IsAlpha(sc.chNext)) {
					sc.SetState(SCE_L_COMMAND);
				} else if (IsTexiSpecial(sc.chNext)) {
					sc.SetState(SCE_L_SPECIAL);
					if (!IsEOLChar(sc.chNext)) {
						sc.Forward();
					}
				}
			} else if (sc.ch == '{' || sc.ch == '}') {
				sc.SetState(SCE_L_OPERATOR);
				if (sc.ch == '{') {
					++braceCount;
				} else if (braceCount > 0) {
					if (braceCount == mathBraceCount) {
						mathBraceCount = 0;
					}
					--braceCount;
					if (braceCount == 0 && outerState != SCE_L_DEFAULT) {
						sc.ForwardSetState(outerState);
						continue;
					}
				}
			} else if (sc.Match('`', '`') || sc.Match('\'', '\'')) {
				sc.SetState(SCE_L_SPECIAL);
				sc.Forward();
			} else if (lineState != 0 || mathBraceCount != 0) {
				if (sc.ch == '\\') {
					if (IsAlpha(sc.chNext)) {
						sc.SetState(SCE_L_TAG);
					} else if (IsAGraphic(sc.chNext) && !IsADigit(sc.chNext)) {
						sc.SetState(SCE_L_SPECIAL);
						sc.Forward();
					}
				} else if (lineState != 0) {
					if (visibleChars == 0 && sc.Match("@end")) {
						sc.SetState(SCE_L_COMMAND);
					} else if (sc.ch == '%') {
						sc.SetState(SCE_L_COMMENT);
					}
				}
			}
		}

		if (visibleChars == 0 && !isspacechar(sc.ch)) {
			++visibleChars;
		}
		if (sc.atLineEnd) {
			if (fold) {
				if (headerLevel) {
					levelNext = headerLevel + SC_FOLDLEVELBASE;
					levelCurrent = levelNext - 1;
					headerLevel = 0;
				}
				const int levelUse = levelCurrent;
				int lev = levelUse | levelNext << 16;
				if (levelUse < levelNext) {
					lev |= SC_FOLDLEVELHEADERFLAG;
				}
				styler.SetLevel(sc.currentLine, lev);
				levelCurrent = levelNext;
			}

			styler.SetLineState(sc.currentLine, lineState | (braceCount << 8));
			visibleChars = 0;
			kwType = KeywordType::None;
			mathBraceCount = 0;
		}
		sc.Forward();
	}

	sc.Complete();
}

}

LexerModule lmTexinfo(SCLEX_TEXINFO, ColouriseTexiDoc, "texi");
